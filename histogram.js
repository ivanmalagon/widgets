/* histogram.html generated by Svelte v1.41.3 */
var Histogram = (function() { "use strict";

	function debounce(func, wait, immediate) {
  var timeout;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
};

function binWidth(bins, width, gutter) {
  return bins && bins.length > 0
    ? Math.max((width - (bins.length - 1) * gutter) / bins.length, 0)
    : 0;
}

	function data() {
  return {
    bins: [],
    width: 0,
    height: 0,
    graphicX: 0,
    graphicY: 0,
    gutter: 2,
    max: '',
    min: '',
    colors: ['#c4e6c3', '#96d2a4', '#6dbc90', '#4da284', '#36877a', '#266b6e', '#1d4f60']
  };
};

	var methods = {
  updateGraphicSize: function () {
    var graphic = this.refs.graphic;
    var graphicRects = graphic.getClientRects();
    if (graphicRects && graphicRects.length > 0) {
      var width = graphicRects[0].width;
      var height = graphicRects[0].height;
      var x = graphicRects[0].x;
      var y = graphicRects[0].y;
    }
    this.set({
      width: width,
      height: height,
      graphicX: x,
      graphicY: y
    });
  },

  hoverRect: function (rectIndex, event) {
    function fix (number) {
      return number % 1 > 0
        ? number.toFixed(1)
        : number;
    }
    var bin = this.get('bins')[rectIndex];
    var text = '' + fix(bin.start) + ' - ' + fix(bin.end) + 'â‚¬: ' + bin.freq + ' apartments';
    var tooltip = this.refs.tooltip;
    var tooltipBg = this.refs.tooltipBg;
    var startX = event.clientX - this.get('graphicX') - 32;
    var startY = event.clientY - this.get('graphicY') - 32;
    tooltip.setAttributeNS(null, 'visibility', 'visible');
    tooltip.setAttributeNS(null, 'x', startX + 8);
    tooltip.setAttributeNS(null, 'y', startY + 16);
    tooltip.firstChild.data = text;
    tooltipBg.setAttributeNS(null, 'visibility', 'visible');
    var tooltipLength = tooltip.getComputedTextLength();
    tooltipBg.setAttributeNS(null, 'x', startX);
    tooltipBg.setAttributeNS(null, 'y', startY);
    tooltipBg.setAttributeNS(null, 'width', tooltipLength + 16);
  },

  hoverOutRect: function (rectIndex) {
    this.hoverOutDebounced.call(this);
  }
};

	function oncreate() {
  this.updateGraphicSize();
  window.addEventListener('resize', this.updateGraphicSize.bind(this));

  this.hoverOutDebounced = debounce(function () {
    var tooltip = this.refs.tooltip;
    var tooltipBg = this.refs.tooltipBg;
    tooltip.setAttributeNS(null, 'visibility', 'hidden');
    tooltipBg.setAttributeNS(null, 'visibility', 'hidden');
  }, 10);
};

	function create_main_fragment(state, component) {
		var div, svg, rect, text, text_1;

		var bins = state.bins;

		var each_blocks = [];

		for (var i = 0; i < bins.length; i += 1) {
			each_blocks[i] = create_each_block(state, bins, bins[i], i, component);
		}

		return {
			c: function create() {
				div = createElement("div");
				svg = createSvgElement("svg");

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].c();
				}

				rect = createSvgElement("rect");
				text = createSvgElement("text");
				text_1 = createText("Tooltip");
				this.h();
			},

			h: function hydrate() {
				div.className = "histogram";
				setAttribute(svg, "width", "100%");
				setAttribute(svg, "height", "128");
				setAttribute(svg, "version", "1.1");
				setAttribute(svg, "xmlns", "http://www.w3.org/2000/svg");
				setAttribute(rect, "class", "tooltipBg");
				setAttribute(rect, "id", "tooltipBg");
				setAttribute(rect, "x", "0");
				setAttribute(rect, "y", "0");
				setAttribute(rect, "width", "52");
				setAttribute(rect, "height", "24");
				setAttribute(rect, "visibility", "hidden");
				setAttribute(text, "class", "tooltip");
				setAttribute(text, "id", "tooltip");
				setAttribute(text, "font-family", "Verdana");
				setAttribute(text, "font-size", "12");
				setAttribute(text, "fill", "white");
				setAttribute(text, "x", "0");
				setAttribute(text, "y", "0");
				setAttribute(text, "visibility", "hidden");
			},

			m: function mount(target, anchor) {
				insertNode(div, target, anchor);
				appendNode(svg, div);
				component.refs.graphic = svg;

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].m(svg, null);
				}

				appendNode(rect, svg);
				component.refs.tooltipBg = rect;
				appendNode(text, svg);
				component.refs.tooltip = text;
				appendNode(text_1, text);
			},

			p: function update(changed, state) {
				var bins = state.bins;

				if (changed.binWidth || changed.gutter || changed.height || changed.bins || changed.Math || changed.colors || changed.event) {
					for (var i = 0; i < bins.length; i += 1) {
						if (each_blocks[i]) {
							each_blocks[i].p(changed, state, bins, bins[i], i);
						} else {
							each_blocks[i] = create_each_block(state, bins, bins[i], i, component);
							each_blocks[i].c();
							each_blocks[i].m(svg, rect);
						}
					}

					for (; i < each_blocks.length; i += 1) {
						each_blocks[i].u();
						each_blocks[i].d();
					}
					each_blocks.length = bins.length;
				}
			},

			u: function unmount() {
				detachNode(div);

				for (var i = 0; i < each_blocks.length; i += 1) {
					each_blocks[i].u();
				}
			},

			d: function destroy() {
				if (component.refs.graphic === svg) component.refs.graphic = null;

				destroyEach(each_blocks);

				if (component.refs.tooltipBg === rect) component.refs.tooltipBg = null;
				if (component.refs.tooltip === text) component.refs.tooltip = null;
			}
		};
	}

	// (3:4) {{#each bins as bin, index}}
	function create_each_block(state, bins, bin, index, component) {
		var rect, rect_x_value, rect_y_value, rect_height_value, rect_fill_value;

		return {
			c: function create() {
				rect = createSvgElement("rect");
				this.h();
			},

			h: function hydrate() {
				setAttribute(rect, "x", rect_x_value = index * (state.binWidth + state.gutter) + 8);
				setAttribute(rect, "y", rect_y_value = state.height - bin.normalized * state.height + 8);
				setAttribute(rect, "width", state.binWidth);
				setAttribute(rect, "height", rect_height_value = ('Math' in state ? state.Math : Math).max(bin.freq * state.height - 8, 0));
				setAttribute(rect, "fill", rect_fill_value = state.bins.length > 0 ? state.colors[('Math' in state ? state.Math : Math).round(state.colors.length * index / state.bins.length)] : '');
				setAttribute(rect, "stroke-width", "0");
				addListener(rect, "mousemove", mousemove_handler);
				addListener(rect, "mouseout", mouseout_handler);

				rect._svelte = {
					component: component,
					bins: bins,
					index: index
				};
			},

			m: function mount(target, anchor) {
				insertNode(rect, target, anchor);
			},

			p: function update(changed, state, bins, bin, index) {
				if ((changed.binWidth || changed.gutter) && rect_x_value !== (rect_x_value = index * (state.binWidth + state.gutter) + 8)) {
					setAttribute(rect, "x", rect_x_value);
				}

				if ((changed.height || changed.bins) && rect_y_value !== (rect_y_value = state.height - bin.normalized * state.height + 8)) {
					setAttribute(rect, "y", rect_y_value);
				}

				if (changed.binWidth) {
					setAttribute(rect, "width", state.binWidth);
				}

				if ((changed.Math || changed.bins || changed.height) && rect_height_value !== (rect_height_value = ('Math' in state ? state.Math : Math).max(bin.freq * state.height - 8, 0))) {
					setAttribute(rect, "height", rect_height_value);
				}

				if ((changed.bins || changed.colors || changed.Math) && rect_fill_value !== (rect_fill_value = state.bins.length > 0 ? state.colors[('Math' in state ? state.Math : Math).round(state.colors.length * index / state.bins.length)] : '')) {
					setAttribute(rect, "fill", rect_fill_value);
				}

				rect._svelte.bins = bins;
				rect._svelte.index = index;
			},

			u: function unmount() {
				detachNode(rect);
			},

			d: function destroy() {
				removeListener(rect, "mousemove", mousemove_handler);
				removeListener(rect, "mouseout", mouseout_handler);
			}
		};
	}

	function mousemove_handler(event) {
		var component = this._svelte.component;
		var bins = this._svelte.bins, index = this._svelte.index, bin = bins[index];
		component.hoverRect(index, event);
	}

	function mouseout_handler(event) {
		var component = this._svelte.component;
		var bins = this._svelte.bins, index = this._svelte.index, bin = bins[index];
		component.hoverOutRect(index);
	}

	function Histogram(options) {
		init(this, options);
		this.refs = {};
		this._state = assign(data(), options.data);
		this._recompute({ bins: 1, width: 1, gutter: 1 }, this._state);

		var _oncreate = oncreate.bind(this);

		if (!options._root) {
			this._oncreate = [_oncreate];
		} else {
		 	this._root._oncreate.push(_oncreate);
		 }

		this._fragment = create_main_fragment(this._state, this);

		if (options.target) {
			this._fragment.c();
			this._fragment.m(options.target, options.anchor || null);

			callAll(this._oncreate);
		}
	}

	assign(Histogram.prototype, methods, {
	 	destroy: destroy,
	 	get: get,
	 	fire: fire,
	 	observe: observe,
	 	on: on,
	 	set: set,
	 	teardown: destroy,
	 	_set: _set,
	 	_mount: _mount,
	 	_unmount: _unmount
	 });

	Histogram.prototype._recompute = function _recompute(changed, state) {
		if (changed.bins || changed.width || changed.gutter) {
			if (differs(state.binWidth, (state.binWidth = binWidth(state.bins, state.width, state.gutter)))) changed.binWidth = true;
		}
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createSvgElement(name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function setAttribute(node, attribute, value) {
		node.setAttribute(attribute, value);
	}

	function insertNode(node, target, anchor) {
		target.insertBefore(node, anchor);
	}

	function appendNode(node, target) {
		target.appendChild(node);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function destroyEach(iterations) {
		for (var i = 0; i < iterations.length; i += 1) {
			if (iterations[i]) iterations[i].d();
		}
	}

	function addListener(node, event, handler) {
		node.addEventListener(event, handler, false);
	}

	function removeListener(node, event, handler) {
		node.removeEventListener(event, handler, false);
	}

	function init(component, options) {
		component.options = options;

		component._observers = { pre: blankObject(), post: blankObject() };
		component._handlers = blankObject();
		component._root = options._root || component;
		component._bind = options._bind;
	}

	function assign(target) {
		var k,
			source,
			i = 1,
			len = arguments.length;
		for (; i < len; i++) {
			source = arguments[i];
			for (k in source) target[k] = source[k];
		}

		return target;
	}

	function callAll(fns) {
		while (fns && fns.length) fns.pop()();
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = this.get = noop;

		if (detach !== false) this._fragment.u();
		this._fragment.d();
		this._fragment = this._state = null;
	}

	function get(key) {
		return key ? this._state[key] : this._state;
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			handlers[i].call(this, data);
		}
	}

	function observe(key, callback, options) {
		var group = options && options.defer
			? this._observers.post
			: this._observers.pre;

		(group[key] || (group[key] = [])).push(callback);

		if (!options || options.init !== false) {
			callback.__calling = true;
			callback.call(this, this._state[key]);
			callback.__calling = false;
		}

		return {
			cancel: function() {
				var index = group[key].indexOf(callback);
				if (~index) group[key].splice(index, 1);
			}
		};
	}

	function on(eventName, handler) {
		if (eventName === 'teardown') return this.on('destroy', handler);

		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this._root._lock) return;
		this._root._lock = true;
		callAll(this._root._beforecreate);
		callAll(this._root._oncreate);
		callAll(this._root._aftercreate);
		this._root._lock = false;
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		for (var key in newState) {
			if (differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign({}, oldState, newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);
		dispatchObservers(this, this._observers.pre, changed, this._state, oldState);
		this._fragment.p(changed, this._state);
		dispatchObservers(this, this._observers.post, changed, this._state, oldState);
	}

	function _mount(target, anchor) {
		this._fragment.m(target, anchor);
	}

	function _unmount() {
		this._fragment.u();
	}

	function differs(a, b) {
		return a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function blankObject() {
		return Object.create(null);
	}

	function noop() {}

	function dispatchObservers(component, group, changed, newState, oldState) {
		for (var key in group) {
			if (!changed[key]) continue;

			var newValue = newState[key];
			var oldValue = oldState[key];

			var callbacks = group[key];
			if (!callbacks) continue;

			for (var i = 0; i < callbacks.length; i += 1) {
				var callback = callbacks[i];
				if (callback.__calling) continue;

				callback.__calling = true;
				callback.call(component, newValue, oldValue);
				callback.__calling = false;
			}
		}
	}
	return Histogram;
}());